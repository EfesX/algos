#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

int main()
{
    // Чтение количества операций
    int n; cin >> n;
    
    // Создание связного списка для хранения элементов
    list<int> ll;
    // Итератор для отслеживания середины списка
    auto mid = ll.begin();

    // Обработка n операций
    while(n--)
    {
        // Чтение типа операции
        char op; cin >> op;

        // Операция добавления элемента в конец
        if(op == '+')
        {
            int g; cin >> g;  // Чтение значения элемента
            ll.push_back(g);   // Добавление элемента в конец

            // Обновление итератора середины
            if(ll.size() == 0 || ll.size() == 1)
                mid = ll.begin();  // Если список пуст или имеет 1 элемент, середина - начало
            else if(ll.size() % 2 != 0)
                mid++;  // Если размер стал нечетным, сдвигаем середину вправо
        }

        // Операция удаления элемента из начала
        else if(op == '-')
        {
            // Вывод и удаление первого элемента
            cout << ll.front() << endl;
            ll.pop_front();

            // Обновление итератора середины
            if(ll.size() == 0 || ll.size() == 1)
                mid = ll.begin();  // Если список пуст или имеет 1 элемент, середина - начало
            else if(ll.size() % 2 != 0)
                mid++;  // Если размер стал нечетным, сдвигаем середину вправо
        }

        // Операция вставки элемента после середины
        else if(op == '*')
        {
            auto it = mid;  // Создаем копию итератора середины

            int g; cin >> g;  // Чтение значения элемента
            ll.insert(++it, g);  // Вставка после середины

            // Обновление итератора середины при нечетном размере
            if(ll.size() % 2 != 0)
                mid++;
        }
    }

    return 0;
}

/*
// Альтернативная версия main (закомментирована)
// Эта версия использует функцию advance для нахождения середины при каждой операции '*'
// что менее эффективно по сравнению с отслеживанием середины через итератор

int main()
{
    int n; cin >> n;

    list<int> ll;

    while(n--)
    {
        char op; cin >> op;

        if(op == '+')
        {
            int g; cin >> g;
            ll.push_back(g);
            continue;
        }

        if(op == '-')
        {
            cout << ll.front() << endl;
            ll.pop_front();
            continue;
        }

        if(op == '*')
        {
            int g; cin >> g;
            auto it = ll.begin();
            advance(it, ll.size() / 2);  // Находим середину каждый раз заново
            ll.insert(it, g);
            continue;
        }
    }

    return 0;
}
*/