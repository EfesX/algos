#include <iostream>
#include <vector>
#include <unordered_set>
#include <bitset>

using namespace std;

// Максимальный размер куба (по условию до 1000)
constexpr int MAXN = 1000; 

int main()
{
    // Оптимизация для ускорения ввода/вывода (важно при больших K до 1e6)
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    // Чтение размеров куба (N) и количества ладей (K)
    int N, K;
    cin >> N >> K;

    // Создаем структуры для хранения информации о занятых линиях:
    // xy[x][y] - есть ли ладья с такими x и y (проекция на XY)
    // xz[x][z] - есть ли ладья с такими x и z (проекция на XZ)
    // yz[y][z] - есть ли ладья с такими y и z (проекция на YZ)
    vector<bitset<MAXN + 1>> xy(N + 1);
    vector<bitset<MAXN + 1>> xz(N + 1);
    vector<bitset<MAXN + 1>> yz(N + 1);

    // Чтение координат K ладей
    for(int i = 0; i < K; ++i)
    {
        int x, y, z;
        cin >> x >> y >> z;

        // Заполняем битовые маски:
        xy[x].set(y); // Ладья в позиции (x,y,*) - отмечаем в XY проекции
        xz[x].set(z); // Ладья в позиции (x,*,z) - отмечаем в XZ проекции
        yz[y].set(z); // Ладья в позиции (*,y,z) - отмечаем в YZ проекции
    }

    // Проверяем каждую возможную клетку (x,y,z) на предмет,
    // бьется ли она хотя бы одной ладьей
    for(int x = 1; x <= N; ++x){
        for(int y = 1; y <= N; ++y){
            // Если в проекции XY уже есть ладья (x,y,*), 
            // то вся линия (x,y,z) для любого z уже бьется - пропускаем
            if(xy[x][y]) continue;

            // Комбинируем информацию о занятых z из проекций XZ и YZ:
            // xz[x] - все z, занятые ладьями на линии (x,*,z)
            // yz[y] - все z, занятые ладьями на линии (*,y,z)
            // Объединение дает все z, которые бьются ладьями по X или Y
            bitset<MAXN + 1> attacked_z = xz[x] | yz[y];
            
            // Инвертируем маску, чтобы получить z, которые НЕ бьются:
            // ~attacked_z - теперь 1 в позициях, где ладьи НЕ бьют
            bitset<MAXN + 1> safe_z = ~attacked_z;
            safe_z.reset(0); // Игнорируем нулевую позицию (индексация с 1)

            // Находим первое z, которое не бьется ни одной ладьей
            size_t z = safe_z._Find_first();

            // Если нашли такое z в допустимом диапазоне [1, N]
            if(z >= 1 && z <= N){
                // Выводим "NO" и координаты безопасной клетки
                cout << "NO" << endl;
                cout << x << " " << y << " " << z << endl;
                return 0; // Завершаем программу
            }
        }
    }

    // Если для всех (x,y,z) хотя бы одна координата бьется ладьей
    cout << "YES" << endl;
    return 0;
}